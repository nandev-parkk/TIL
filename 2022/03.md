# 3월 20일(일)

잠시 멈췄던 패스트캠퍼스 리액트 강의를 다시 듣기 시작했다.

- createElement(type, [props], [...children]): 리액트 엘리먼트 생성
- ReactDOM.render(자식 컴포넌트, 부모 컴포넌트): 부모 컴포넌트에 자식 컴포넌트 주입
- JSX: 자바스크립트의 확장 문법으로, 모든 값들을 변수화해서 사용할 수 있다. 기본적으로 자바스크립트가 해석할 수 없기 때문에 babel과 같은 compiler가 필요하다.
- Fragment: 리액트에서 빈 엘리먼트를 의미한다. <React.Fragment></React.Fragment> 또는 <></>로 사용한다.
- 블로그에 createElement() API 정리

<br /><br />

# 3월 21일(월)

1. 리액의 강의 수강

- 리액트에서는(JSX) 함수의 형태로 element를 만들어 사용한다.
- element에는 첫글자를 대문자로 작성하며 props를 줄 수 있고 무한히 자식 element를 생성할 수 있다.
- 리액트에서는 js와 jsx를 섞어서 사용한다.(interpolation)
- vanilla js는 element에 변경이 있을시 element 전체를 다시 그리지만, 리액트는 변경된 부분만 다시 그린다.
- 리액트 element는 불변객체(immutable)이다.
- 리액트는 virtual DOM를 사용하며 자체 알고리즘을 통해 변경사항을 확인하다.
- 변경되기 전과의 DOM tree를 비교해서 element의 type이 같다면 key를 비교한 후 props를 비교해서 변경사항을 반영하고, type이 다르다면 element를 새로 그린다.

<br /><br />

# 3월 23일(수)

1. 리액트 강의 수강

- vanilla js에서 event는 html tag에 inline으로 on{eventName}으로 주거나 addEventListener를 통해 줄 수 있다. 둘 다 적용할 시 모두 동작한다.

- 리액트에서는 inline으로 on{EventName}으로 표현한다. vanilla js는 event name이 소문자, 리액트는 대문자이다.

- 리액트에서도 addEventListener를 사용할 수 있지만 리액트에서 제공하는 표준은 inline으로 함수를 넣는 방법이다.
- component는 element의 집합이다.

- [useState]

  - 리액트에서 컴포넌트 상태 관리는 useState로 한다. useState의 초기값에는 어떤 data type이든지 들어갈 수 있다.
  - useState에는 초기값을 리턴하는 함수를 값으로 넣어줄 수 있다. 초기값이 클경우 불러오는데 시간이 걸릴 수 있기 때문에 이렇게하면 딜레이를 주게된다.

```javascript
const [관리할 값, 값을 업데이트해주는 함수] = React.useState(초기값);

const [keyword, setKeyword] = React.useState("");

// 위 코드는 아래와 같다
const keywordState = React.useState("");
const keyword = keywordState[0];
const setKeyword = keywordState[1];
```

- [useEffect]

  - 리액트에서 사이드이펙트는 useEffect로 다룬다.
  - 두번째 인자의 값의 변화에 따라 동작하는 코드를 작성한다.

```javascript
React.useEffect(함수, dependency array)

// 모든 변화에 다 동작
React.useEffect(() => {})

// 최초 렌더시 한번만 동작
React.useEffect(() => {}, [])

// 조건 변화시에만 동작
React.useEffect(() => {}, [keyword, typing])

```

- 커스텀 훅
  - use{HookName} 형태로 만든다.
  - vanilla js에서 반복되는 코드를 함수화 하듯이 useState와 useEffect와 같이 hook이 반복될 때는 커스텀 훅을 사용한다.

<br /><br />

# 3월 24일(목)

1. 리액트 강의 수강

- useState로 만들어진 set함수는 인자로 이전 값이 들어온다.

```javascript
// 만약 button 클릭시 state의 boolean 값에 따라 input창이 보여지고/사라져야 한다면

const [show, setShow] = React.useState(false);

// 이렇게 구현할 수도 있지만
function handleClick() {
  if (show) {
    setShow(false);
  } else {
    setShow(true);
  }
}

// set함수에는 첫번째 인자로 이전값이 들어기 때문에 아래와 같이 구현할 수 있다.
// 이전값이 true면 false로, false면 true로 변경한다.
function handleClick() {
  setShow((prev) => !prev);
}

// 또는 아래와 같이 구현도 가능하다.
function handleClick() {
  setShow(!show);
}
```

- useEffect는 작성한 순서에 따라 호출된다.
- useEffect는 사이드 이펙트이기 때문에 component의 render가 끝난 뒤 순서대로 호출된다.
- 최초 렌더시 hook flow
  > - render start
  > - useState call
  > - render end
  > - useEffect call

<br />

- update시 hook flow
  > - render start
  > - render end
  > - useEffect(dependency array에 따라 해당하는) call

<br />

- parent component에 useState && useEffect가 없는 child component가 있을시 flow
  > - parent render start
  > - parent useState call
  > - parent render end
  > - child render start
  > - child render end
  > - parent useEffect call

<br />
 
- parent component에 useState && useEffect가 있는 child component가 있을시 flow
  > - parent render start
  > - parent useState call
  > - parent render end
  > - child render start
  > - child useState call
  > - child render end
  > - child useEffect call
  > - parent useEffect call

<br />

- useEffect에는 clean up 동작이 있다.
- clean up은 기존에 세팅되어있던 effect를 지우고 새로운 effect를 생성하는 동작이다.
- update시 clean up이 먼저 실행되고 기존의 effect가 실행된다.

```javascript
React.useEffect(() => {
  conosle.log("useEffect");

  // clean up
  return () => {
    conosle.log("clean up");
  };
});
```

<br /><br />

# 3월 25일(금)

1. 리액트 강의 수강

- 컴포넌트에서 props를 받을 때 전체 props는 인자로 그냥 받고 구조분해해서 받을 때는 {}안에 입력해서 받는다.

```javascript

// props 전체
function Button({ ...children }) {
  return <button {...children} />
}

// props 전체
function Button(props) {
  return <button {...props} />
}

//  ...rest에는 className과 stlye을 제외한 props들이 들어간다.
function Button({className, style, ...rest}) {
  return <button {...rest} />
}

//  ...rest 안에 className blue가 있지만 className을 ...rest 뒤에 입력하게되면 덮어쓰게 되서 button className만 입력된다.
function Button({style, ...rest}) {
  return <button {...rest} className="button" />
}

//  className이 없다면 className props에 기본값으로 ""를 준다.
function Button({className = "", style, ...rest}) {
  return <button className={`button ${className}`} {...rest} />
}

// 예시
<Button className="button blue" style={{ borderRadius: 10 }}>버튼<Button>

<Button style={{ borderRadius: 10 }}>버튼<Button>

```

- React에서 DOM를 다룰 때는 useRef hook을 사용한다. ref는 reference의 줄임말이다.
- React에서 js에서 DOM을 다루는 기존의 방법 대신 useRef hook을 제공한 이유
  - 리액트에서 효율적으로 element를 관리하기 위해 사용하는 virtual DOM이나 알고리즘 대신 직접적으로 DOM를 조작하게 되면 비효율적이기 때문이다. 즉, 리액트가 권장하는 틀 안에서 DOM을 조작하도록 하기 위해 useRef hook을 제공한다.
- useRef를 사용해 element 외에 특정 값을 넣을 수도 있다.
- 접근할 때는 ref이름.current.특정 동작으로 접근한다.

```javascript
const App = () => {
  const inputRef = React.useRef();

  React.useEffect(() => {
    inputRef.current.focus();
  }, []);

  return <input ref={inputRef} />;
};
```

- 리액트에서는 label element에 for 대신 htmlFor로 사용하기를 권장한다.
- 리액트에서는 input 태그 value 값에 정적으로 기본값이 들어간다면 value 대신 defaultValue로 사용하기를 권장한다.
